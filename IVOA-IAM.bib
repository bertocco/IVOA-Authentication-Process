@misc{rfc7235,
    series =    {Request for Comments},
    number =    7235,
    howpublished =  {RFC 7235},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC7235},
    url =       {https://www.rfc-editor.org/info/rfc7235},
    author =    {Roy T. Fielding and Julian Reschke},
    title =     {{Hypertext Transfer Protocol (HTTP/1.1): Authentication}},
    pagetotal = 19,
    year =      2014,
    month =     jun,
    abstract =  {The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems. This document defines the HTTP Authentication framework.},
}


@misc{rfc6265,
    series =    {Request for Comments},
    number =    6265,
    howpublished =  {RFC 6265},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC6265},
    url =       {https://www.rfc-editor.org/info/rfc6265},
    author =    {Adam Barth},
    title =     {{HTTP State Management Mechanism}},
    pagetotal = 37,
    year =      2011,
    month =     apr,
    abstract =  {This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 2965. {[}STANDARDS-TRACK{]}},
}

@misc{rfc7617,
    series =    {Request for Comments},
    number =    7617,
    howpublished =  {RFC 7617},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC7617},
    url =       {https://www.rfc-editor.org/info/rfc7617},
    author =    {Julian Reschke},
    title =     {{The 'Basic' HTTP Authentication Scheme}},
    pagetotal = 15,
    year =      2015,
    month =     sep,
    abstract =  {This document defines the "Basic" Hypertext Transfer Protocol (HTTP) authentication scheme, which transmits credentials as user-id/ password pairs, encoded using Base64.},
}

@misc{rfc6749,
    series =    {Request for Comments},
    number =    6749,
    howpublished =  {RFC 6749},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC6749},
    url =       {https://www.rfc-editor.org/info/rfc6749},
    author =    {Dick Hardt},
    title =     {{The OAuth 2.0 Authorization Framework}},
    pagetotal = 76,
    year =      2012,
    month =     oct,
    abstract =  {The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849. {[}STANDARDS-TRACK{]}},
}

@misc{rfc6750,
    series =    {Request for Comments},
    number =    6750,
    howpublished =  {RFC 6750},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC6750},
    url =       {https://www.rfc-editor.org/info/rfc6750},
    author =    {Michael B. Jones and Dick Hardt},
    title =     {{The OAuth 2.0 Authorization Framework: Bearer Token Usage}},
    pagetotal = 18,
    year =      2012,
    month =     oct,
    abstract =  {This specification describes how to use bearer tokens in HTTP requests to access OAuth 2.0 protected resources. Any party in possession of a bearer token (a "bearer") can use it to get access to the associated resources (without demonstrating possession of a cryptographic key). To prevent misuse, bearer tokens need to be protected from disclosure in storage and in transport. {[}STANDARDS-TRACK{]}},
}
@misc{rfc8628,
    series =    {Request for Comments},
    number =    8628,
    howpublished =  {RFC 8628},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8628},
    url =       {https://www.rfc-editor.org/info/rfc8628},
    author =    {William Denniss and John Bradley and Michael B. Jones and Hannes Tschofenig},
    title =     {{OAuth 2.0 Device Authorization Grant}},
    pagetotal = 21,
    year =      2019,
    month =     aug,
    abstract =  {The OAuth 2.0 device authorization grant is designed for Internet- connected devices that either lack a browser to perform a user-agent- based authorization or are input constrained to the extent that requiring the user to input text in order to authenticate during the authorization flow is impractical. It enables OAuth clients on such devices (like smart TVs, media consoles, digital picture frames, and printers) to obtain user authorization to access protected resources by using a user agent on a separate device.},
}

@misc{rfc8414,
    series =    {Request for Comments},
    number =    8414,
    howpublished =  {RFC 8414},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8414},
    url =       {https://www.rfc-editor.org/info/rfc8414},
    author =    {Michael B. Jones and Nat Sakimura and John Bradley},
    title =     {{OAuth 2.0 Authorization Server Metadata}},
    pagetotal = 23,
    year =      2018,
    month =     jun,
    abstract =  {This specification defines a metadata format that an OAuth 2.0 client can use to obtain the information needed to interact with an OAuth 2.0 authorization server, including its endpoint locations and authorization server capabilities.},
}

@misc{rfc7591,
    series =    {Request for Comments},
    number =    7591,
    howpublished =  {RFC 7591},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC7591},
    url =       {https://www.rfc-editor.org/info/rfc7591},
    author =    {Justin Richer and Michael B. Jones and John Bradley and Maciej Machulak and Phil Hunt},
    title =     {{OAuth 2.0 Dynamic Client Registration Protocol}},
    pagetotal = 39,
    year =      2015,
    month =     jul,
    abstract =  {This specification defines mechanisms for dynamically registering OAuth 2.0 clients with authorization servers. Registration requests send a set of desired client metadata values to the authorization server. The resulting registration responses return a client identifier to use at the authorization server and the client metadata values registered for the client. The client can then use this registration information to communicate with the authorization server using the OAuth 2.0 protocol. This specification also defines a set of common client metadata fields and values for clients to use during registration.},
}

@misc{rfc7592,
    series =    {Request for Comments},
    number =    7592,
    howpublished =  {RFC 7592},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC7592},
    url =       {https://www.rfc-editor.org/info/rfc7592},
    author =    {Justin Richer and Michael B. Jones and John Bradley and Maciej Machulak},
    title =     {{OAuth 2.0 Dynamic Client Registration Management Protocol}},
    pagetotal = 18,
    year =      2015,
    month =     jul,
    abstract =  {This specification defines methods for management of OAuth 2.0 dynamic client registrations for use cases in which the properties of a registered client may need to be changed during the lifetime of the client. Not all authorization servers supporting dynamic client registration will support these management methods.},
}

@misc{rfc8252,
    series =    {Request for Comments},
    number =    8252,
    howpublished =  {RFC 8252},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8252},
    url =       {https://www.rfc-editor.org/info/rfc8252},
    author =    {William Denniss and John Bradley},
    title =     {{OAuth 2.0 for Native Apps}},
    pagetotal = 21,
    year =      2017,
    month =     oct,
    abstract =  {OAuth 2.0 authorization requests from native apps should only be made through external user-agents, primarily the user's browser. This specification details the security and usability reasons why this is the case and how native apps and authorization servers can implement this best practice.},
}